---
title: 'Object'
description: 'The `Flow` object exposes useful information about the current flow and allows transitioning between steps in the flow.'
---

The `Flow` object gives you control over how the assistant moves between steps in a flow. It is most commonly used inside **transition functions**, where deterministic logic determines what happens next.

<Warning>
Only the **last** `flow.goto_step()` call in a function is executed. To prevent accidental overrides, always use `return` immediately after a `goto_step()` call ‚Äî unless you're explicitly chaining transitions.
</Warning>

## `current_step` (Property)

**Type:** `string`
**Returns:** The name of the current step the assistant is in.

```python
if flow.current_step == "Collect Name":
    return "You're in the name collection step."
```

Use this for debugging, conditional routing, or gracefully recovering from skipped steps.


## `goto_step(step_name)` (Method)

Use `flow.goto_step()` to move the assistant to another step in the flow. This replaces the current step‚Äôs prompt and functions with those of the target step.

```python
flow.goto_step("Confirm Name")
return
```

Only the prompt and functions in the **current step** are visible to the LLM ‚Äî step names, flow names, and previous prompts are not included in its context.

<Note>
Use `return` immediately after calling `goto_step()` to avoid silent failures. Only the final call in a function is executed.
</Note>

### Conditional transition example

```python
if conv.state.has_phone_number:
    flow.goto_step("Confirm phone number")
    return
else:
    flow.goto_step("Collect phone number")
    return
```

### Input validation and state update

```python
def transition_to_confirm_name(conv: Conversation, flow: Flow, first_name: str, last_name: str):
    if not first_name or not last_name:
        return "Please make sure we have both first and last name before continuing."

    conv.state.first_name = first_name
    conv.state.last_name = last_name

    flow.goto_step("Confirm Name")
    return
```

This is the recommended structure for transition logic: validate input, update state, transition, then return.

## Prompt visibility rules

- ‚úÖ The LLM sees: the **current step prompt** and the **list of functions defined in the step**.
- ‚ùå The LLM does **not** see:
  - The flow or step name
  - Prompts from earlier steps
  - Code comments
- üí° Function and argument **names and descriptions are treated as prompts** ‚Äî write them clearly and actionably.

<Note>
If your function is called `go_to_step_two`, the LLM may generate irrelevant responses like ‚ÄúOkay, moving on.‚Äù Use intent-based names like `check_user_info` or `verify_email` to anchor model behavior.
</Note>

## Best practices

- ‚úÖ Design flows like **state machines** ‚Äî each step represents a specific state with a clear transition path.
- ‚úÖ Keep transition functions short and scoped to a single decision.
- ‚ùå Avoid chaining multiple function calls in the same function ‚Äî consolidate them into a single utility or flow function.

```python
# ‚ùå Don't do this
save_user_input()
check_availability()
flow.goto_step("Next")
return
```

```python
# ‚úÖ Better
def handle_input_and_continue(conv: Conversation, flow: Flow, input: str):
    if is_valid(input):
        conv.state.user_input = input
        if check_availability(input):
            flow.goto_step("Confirm")
        else:
            flow.goto_step("Unavailable")
        return
    return "That input didn‚Äôt look right. Can you try again?"
```

## Good to know

- Any step in a flow can be designated as the **start step** in the UI.
- Use `current_step` for step-aware debugging or conditional re-routing.
- **Exit steps** are defined using `conv.exit_flow()` and are visually marked in yellow in the Flow Editor.
- Transition functions live **inside flows**, not globally ‚Äî reuse shared logic via global utility functions instead.
- Function names affect both **behavior and language** ‚Äî treat them as part of your prompt design.

<Tip>
Think of each step as a container: one prompt, one set of functions, one decision. The `Flow` object lets you move between these containers with precision.
</Tip>