---
title: 'Introduction'
description: 'An overview of how flows and prompting work inside the PolyAI agent runtime.'
---

This documentation explains how to build and maintain conversational flows in the PolyAI runtime, using a combination of:

- Deterministic logic via functions and state
- Language generation via LLM prompting
- Flow structure and step transitions

A flow is a structured interaction made up of **steps**, each containing a prompt and one or more actions. You use flows when an interaction requires:

- Data collection (e.g. phone number, address, name)
- Validation or retries
- External API calls
- Routing, handoff, or escalation
- Enforcement of business logic or process compliance

## When to use a flow vs. knowledge base

- Use the **Knowledge Base** for short, simple questions (1–3 turn answers).
- Use a **Flow** when:
  - The conversation needs to follow a specific structure
  - You want to guide or constrain the LLM
  - You need to call functions, collect multiple fields, or hand off to an agent

## Prompt visibility and scope

Each **step acts as its own context window** for the LLM. The LLM only sees:

- The current step’s prompt
- The function names and descriptions listed in that step

The LLM **does not see**:
- Previous steps
- Flow names
- Flow descriptions
- Comments or implementation details outside the current prompt

As a result, your prompts must be written **as if they are self-contained instructions**.

## Prompting philosophy

This runtime uses a **few-shot prompting (FSP)** strategy where applicable. This means you can:

- Include short example exchanges within a step to guide the model
- Embed function names and descriptions in plain language
- Use explicit phrasing to encourage function calling, e.g.
      "Call `check_availability` now before responding to the user."

## Designing flows

- Design flows as **state machines** — each step should represent a single state of the interaction.
- Move between steps using `flow.goto_step()`, always followed by `return`.
- Use transition functions to determine logic for branching, validation, and navigation.

    if not user_email:
        flow.goto_step("Collect email")
        return

- Avoid ambiguous prompts or future-looking function names. For example, prefer `check_availability` over `make_successful_booking`.

## Advanced features

### Conditional logic
Flows can include conditions to dynamically adapt responses based on user input. For example:
- If a user provides a specific date, the agent can check availability and guide the user accordingly.

### Variables in prompts
Flows support the use of [variables](/variant-management/introduction) to dynamically fill in information during interactions. This allows for personalized and context-aware responses.

### ASR biasing
- Configure ASR biasing for specific steps to improve transcription accuracy for numbers, postcodes, or other alphanumeric inputs.
- Boost keywords to prioritize relevant user inputs during transcription.

## Example flow

<Tip> Full or partial flows can be easily copied between projects using `Cmd/Ctrl + C` and `Cmd/Ctrl + V` </Tip>

Here's an example of a flow for making a restaurant reservation:

1. **Start step**: Collect the date, time, and number of people.
   - Prompt: "What date and time would you like to book a table for? How many people will be dining?"
   - Function: `CollectReservationDetails`

2. **Check availability**:
   - Call an API to check availability based on user input.
   - If available: Transition to the confirmation step.
   - If unavailable: Prompt the user to choose a different time.

3. **Confirmation step**:
   - Prompt: "Great! Your table is booked for [date] at [time] for [number of people]. Is there anything else I can help you with?"
   - Function: `ExitFlow`

## Connecting steps

![connect-flow-steps](/images/connect-flow-steps.png)

You can connect flow steps from the **prompt** field:

 1. Type "/" in the prompt field.
 2. Scroll down until you find **Steps**.
 3. You will see a searchable and scrollable list of all the current flow steps. Select one to create a flow function.
 4. Name your transition flow function, or retain the autogenerated name.in

![name-flow-function](/images/add-flow-function.png)

### Managing transition functions

![flow-functions](/images/flow-functions-button.png)

Find the **<Icon icon="arrow-progress" iconType="solid" /> Flow functions**
button in the bottom-right corner of the flow editor. Click it to open a modal displaying a searchable list of all the [functions](/function/introduction) associated with the flow.

1. If no transitions exist, you can manually create them by connecting steps.
2. When selecting a step to connect, you can **name the transition** rather than relying on an auto-generated name.
3. If a name is already in use, an error message will prompt you to resolve it before proceeding.
4. Once a transition is created, the UI displays its **references**, showing how many times it appears in prompts.
5. Transitions can be managed in two ways:

      - **Directly from a step**, by selecting an option from the context menu.
      - **In the flow editor**, by selecting an existing transition and connecting steps accordingly.
6. Users can also **duplicate** transitions, in which case the duplicate will automatically be uniquely named.

## Troubleshooting

- **Missing exit step**: Failing to exit a flow can lead to the agent repeating unnecessary steps or ignoring new user queries.
- **Overloading steps**: Including too much information in a single step can overwhelm both the agent and the user.
- **Poorly-named functions**: Functions with vague or misleading names can cause unexpected behavior. Remember that when using
the PolyAI Agent Studio, all title and description fields matter to the LLM.

## Resources

- [Flow object reference](./object)
- [Prompting tips](./prompting)
- [Function definition and syntax](./functions)