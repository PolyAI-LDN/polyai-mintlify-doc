---
title: 'Overview'
description: 'Manage complex tasks.'
---

<Tip> If you are looking for a function that only exists inside a single [flow](/flows/introduction), visit the [transition functions](/flows/transition-functions) page. </Tip>

Functions are custom Python scripts designed to handle tasks requiring deterministic logic or API integrations. They enhance the agent's
ability to interact with external systems and allow for advanced customization of responses. Use [`conv.log`](./classes/conv-log) to write structured logs that appear in **Conversation review → Diagnosis** and via the Conversations API.

For detailed guides, explore the subpages below:

## Subpages
1. **[How to set up a function](./how-to-setup)**:
   Learn how to set up a function, including naming conventions, parameter definitions, and writing Python code.

2. **[How to import libraries](./import-library)**:
   Understand how to use standard and non-standard libraries within your function, enabling external API integrations.

3. **[How to start a function](./start-function)**:
   Discover the role of the `start_function` in initializing conversation context and preparing data before user interactions.

4. **[Understanding return values](./return-values)**:
   Explore how to use string and dictionary return values to dynamically guide the agent's behavior.

5. **[Using the `conv` object](./classes/conv-object)**:
   Reference the `conv` object to manage conversation states, flows, and telephony-related attributes effectively.

6. **[Working with variables](./variables)**:
   Learn how to define, update, and persist variables across turns using the conversation state.

7. **[Invoking functions in the knowledge base](./using-functions-in-knowledge-base)**:
   Discover methods for integrating functions into the knowledge base and testing their usage effectively.

8. **[The delay controls interface](./delay-control)**:
   Keep the conversation on track in high-latency functions by adding delay phrases.

9. **[Logging from functions (conv.log)](./classes/conv-log)**:
   Record structured diagnostics and PII-scoped entries for review in **Diagnosis** and export via the API.

10. **[Conversation utilities (conv.utils)](./classes/conv-utils)**:
    Use built-in helpers to extract and validate structured data like addresses and cities from user input.

11. **[Agent memory](./classes/conv-memory)**:
    Store and retrieve persistent data about users across conversations for repeat-caller logic and personalization.

 <Tip> If you are looking to use functions to enable multi-site configuration, like handling reservations for multiple restaurant locations, visit the [variant management](/variant-management/introduction) feature page. </Tip>

## Design best practices

1. **Clear naming conventions**:
   - Always use descriptive, action-oriented names (e.g., `book_reservation`, `send_notification`).
   - Avoid vague or misleading names that might confuse the agent or developers.

2. **Comprehensive descriptions**:
   - Provide explicit descriptions of what the function does, its parameters, and expected outputs.
   - Ensure the description aligns with the agent's broader purpose and use case.

3. **Precise argument definitions**:
   - Use clear and meaningful argument names (e.g., `date`, `time`, `guest_count`).
   - Document the purpose of each argument in the function's docstring.

4. **Control over triggering**:
   - Define specific [rules](/agent-settings/rules) and conditions in the agent's prompts to ensure functions are only called when necessary.
   - Avoid over-triggering or under-triggering by refining language inputs and prompts.

5. **Readable parameter names**:
   - Use user-friendly parameter names to improve LLM comprehension (e.g., `reservation_date` over `r_date`).

## Using functions

1. **Avoid misleading triggers**:
   - Ensure the rules and knowledge base accurately describe when to call a function.
   - Use precise language in prompts to reduce ambiguity.

2. **Provide detailed metadata**:
   - Add comprehensive descriptions in function definitions to guide the LLM effectively.
   - Metadata should include the function's purpose, parameters, and conditions for triggering.

3. **Implement fallback mechanisms**:
   - Use [stop keywords](/response-control/introduction#use-stop-keywords-to-remove-unnecessary-preambles) or catch-all conditions to prevent functions from misfiring.
   - Test functions in simulated environments to ensure reliability.

4. **Define in the knowledge base**:
   - Clearly state the function's purpose and conditions for usage in the knowledge base rules.

5. **Add function descriptions**:
   - Provide detailed explanations in the agent's system prompts to guide its behavior effectively.

6. **Iterative testing**:
   - Test functions in multiple scenarios to refine behavior and improve reliability. Use Test Cases and Test Sets, and optionally configure sets to run automatically on publish/promote.

## Troubleshooting tips

1. **Debugging triggers**:
   - Review **Conversation review → Diagnosis** (including `conv.log` entries) to ensure functions are called at the appropriate time and with the correct parameters.

2. **Checking outputs**:
   - Validate function outputs against expected results, especially when integrating external APIs.

3. **Improving LLM comprehension**:
   - Simplify function descriptions and prompts if the agent struggles to trigger them appropriately.

4. **Monitoring user interactions**:
   - Analyze real-world usage data to identify and resolve any inconsistencies in function behavior.