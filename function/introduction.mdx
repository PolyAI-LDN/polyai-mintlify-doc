---
title: 'Overview'
description: 'Overview of functions including creation, invocation, and secret retrieval'
---

Functions are custom Python scripts designed to handle tasks requiring deterministic logic or API integrations. They enhance the assistant's
ability to interact with external systems and allow for advanced customization of responses.

For detailed guides, explore the subpages below:


## Subpages
1. **[How to set up a function](./how-to-setup)**:
   Learn how to set up a function, including naming conventions, parameter definitions, and writing Python code.

2. **[How to import libraries](./import-library)**:
   Understand how to use standard and non-standard libraries within your function, enabling external API integrations.

3. **[How to start a function](./start-function)**:
   Discover the role of the `start_function` in initializing conversation context and preparing data before user interactions.

4. **[Understanding return values](./return-values)**:
   Explore how to use string and dictionary return values to dynamically guide the assistant's behavior.

5. **[Using the `conv` object](./conv-object)**:
   Reference the `conv` object to manage conversation states, flows, and telephony-related attributes effectively.

6. **[Working with variables](./variables)**:
   Learn how to define, update, and persist variables across turns using the conversation state.

7. **[Invoking functions in the knowledge base](./using-functions-in-knowledge-base)**:
   Discover methods for integrating functions into the knowledge base and testing their usage effectively.

## Design best practices

1. **Clear naming conventions**:
   - Always use descriptive, action-oriented names (e.g., `book_reservation`, `send_notification`).
   - Avoid vague or misleading names that might confuse the assistant or developers.

2. **Comprehensive descriptions**:
   - Provide explicit descriptions of what the function does, its parameters, and expected outputs.
   - Ensure the description aligns with the assistant's broader purpose and use case.

3. **Precise argument definitions**:
   - Use clear and meaningful argument names (e.g., `date`, `time`, `guest_count`).
   - Document the purpose of each argument in the function's docstring.

4. **Control over triggering**:
   - Define specific rules and conditions in the assistant's prompts to ensure functions are only called when necessary.
   - Avoid over-triggering or under-triggering by refining language inputs and prompts.

5. **Readable parameter names**:
   - Use user-friendly parameter names to improve LLM comprehension (e.g., `reservation_date` over `r_date`).

## Using functions

1. **Avoid misleading triggers**:
   - Ensure the rules and knowledge base accurately describe when to call a function.
   - Use precise language in prompts to reduce ambiguity.

2. **Provide detailed metadata**:
   - Add comprehensive descriptions in function definitions to guide the LLM effectively.
   - Metadata should include the function’s purpose, parameters, and conditions for triggering.

3. **Implement fallback mechanisms**:
   - Use stop keywords or catch-all conditions to prevent functions from misfiring.
   - Test functions in simulated environments to ensure reliability.

4. **Define in the knowledge base**:
   - Clearly state the function's purpose and conditions for usage in the knowledge base rules.

5. **Add function descriptions**:
   - Provide detailed explanations in the assistant’s system prompts to guide its behavior effectively.

6. **Iterative testing**:
   - Test functions in multiple scenarios to refine behavior and improve reliability.

## Troubleshooting tips

1. **Debugging triggers**:
   - Review logs to ensure functions are called at the appropriate time and with the correct parameters.

2. **Checking outputs**:
   - Validate function outputs against expected results, especially when integrating external APIs.

3. **Improving LLM comprehension**:
   - Simplify function descriptions and prompts if the assistant struggles to trigger them appropriately.

4. **Monitoring user interactions**:
   - Analyze real-world usage data to identify and resolve any inconsistencies in function behavior.
